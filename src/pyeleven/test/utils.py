import atexit
import logging
import os
import subprocess
import tempfile
import traceback
import unittest
from shutil import copyfile, rmtree
from threading import Thread

import six

from pyeleven.test import P11_MODULE, PKCS11_TOOL, SOFTHSM, OPENSSL

if six.PY2:
    from Queue import Queue
else:
    from queue import Queue

logger = logging.getLogger(__name__)


# from http://code.activestate.com/recipes/577187-python-thread-pool/
class Worker(Thread):
    """Thread executing tasks from a given tasks queue"""
    def __init__(self, tasks):
        Thread.__init__(self)
        self.tasks = tasks
        self.daemon = True
        self.start()

    def run(self):
        while True:
            func, args, kargs = self.tasks.get()
            try: func(*args, **kargs)
            except Exception as e:
                print(e)
            self.tasks.task_done()


class ThreadPool:
    """Pool of threads consuming tasks from a queue"""
    def __init__(self, num_threads):
        self.tasks = Queue(num_threads)
        for _ in range(num_threads):
            Worker(self.tasks)

    def add_task(self, func, *args, **kargs):
        """Add a task to the queue"""
        self.tasks.put((func, args, kargs))

    def wait_completion(self):
        """Wait for completion of all the tasks in the queue"""
        self.tasks.join()


class TemporarySoftHSM(object):

    _instance = None

    @classmethod
    def get_instance(cls):
        if cls._instance is None:
            cls._instance = cls()
            atexit.register(cls._instance.clean_up)
        return cls._instance

    def __init__(self):
        self.p11_test_files = []

        self.softhsm_conf = self._tf()
        self.softhsm_db_1 = self._tf()
        self.softhsm_db_2 = self._tf()
        self.softhsm_token_dir = self._td()
        self.signer_cert_pem = self._tf()
        self.openssl_conf = self._tf()

        self.setup_hsm()

    def setup_hsm(self):
        if not P11_MODULE:
            raise unittest.skip("SoftHSM PKCS11 module not installed")
        logger.debug("Creating test pkcs11 token using softhsm")
        try:
            logger.debug("Generating softhsm.conf")
            with open(self.softhsm_conf, "w") as f:
                f.write("#Generated by pyeleven test\n0:%s\n1:%s\ndirectories.tokendir=%s\n" % (self.softhsm_db_1,
                                                                                                self.softhsm_db_2,
                                                                                                self.softhsm_token_dir))
            logger.debug("Initializing the token")
            self._p([SOFTHSM,
                     '--slot', '0',
                     '--label', 'test',
                     '--init-token',
                     '--pin', 'secret1',
                     '--so-pin', 'secret2'])

            private_key_pem = self._tf()
            private_key_der = self._tf()
            logger.debug("Generating private key (PEM format)")
            self._p([OPENSSL,
                     'genrsa',
                     '-out', private_key_pem,
                     '1024'])

            logger.debug("Generating private key (DER format)")
            self._p([OPENSSL,
                     'rsa',
                     '-inform', 'PEM',
                     '-outform', 'DER',
                     '-in', private_key_pem,
                     '-out', private_key_der])

            logger.debug("Importing private key in token")
            self._p([PKCS11_TOOL,
                     '--module', P11_MODULE,
                     '--login',
                     '--id', 'a1b2',
                     '--label', 'test',
                     '--type', 'privkey',
                     '--write-object', private_key_der,
                     '--pin', 'secret1'])

            logger.debug("Listing objects in token")
            self._p([PKCS11_TOOL,
                     '--module', P11_MODULE,
                     '--login',
                     '--pin', 'secret1',
                     '--list-objects'])

            logger.debug("Generating OpenSSL config")
            with open(self.openssl_conf, "w") as f:
                f.write("""
    [req]
    distinguished_name = req_distinguished_name

    [req_distinguished_name]
                    """)

            signer_cert_der = self._tf()

            logger.debug("Generating self-signed certificate")
            self._p([OPENSSL, 'req',
                     '-new',
                     '-x509',
                     '-subj', "/cn=TestSigner",
                     '-config', self.openssl_conf,
                     '-keyform', 'PEM',
                     '-key', private_key_pem,
                     '-out', self.signer_cert_pem])

            self._p([OPENSSL, 'x509',
                     '-inform', 'PEM',
                     '-outform', 'DER',
                     '-in', self.signer_cert_pem,
                     '-out', signer_cert_der])

            logger.debug("Importing certificate into token")

            self._p([PKCS11_TOOL,
                     '--module', P11_MODULE,
                     '--login',
                     '--id', 'a1b2',
                     '--label', 'test',
                     '--type', 'cert',
                     '--write-object', signer_cert_der,
                     '--pin', 'secret1'])

            copyfile(self.softhsm_db_1, self.softhsm_db_2)

        except Exception as ex:
            traceback.print_exc()
            logger.warning("PKCS11 tests disabled: unable to initialize test token: %s" % ex)

    def _tf(self):
        f = tempfile.NamedTemporaryFile(delete=False)
        self.p11_test_files.append(f.name)
        return f.name

    def _td(self):
        dirpath = tempfile.mkdtemp()
        self.p11_test_files.append(dirpath)
        return dirpath

    def _p(self, args):
        env = {}
        if self.softhsm_conf is not None:
            env['SOFTHSM2_CONF'] = self.softhsm_conf
            logger.debug("env SOFTHSM2_CONF=%s " % self.softhsm_conf + " ".join(args))
        logger.info("Running: " + " ".join(args))
        proc = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE, env=env)
        out, err = proc.communicate()
        if err is not None and len(err) > 0:
            logger.error(err)
        if out is not None and len(out) > 0:
            logger.debug(out)
        rv = proc.wait()
        if rv:
            raise RuntimeError("command exited with code != 0: %d" % rv)

    @staticmethod
    def disable_tf(fn):
        if os.path.exists(fn):
            try:
                os.rename(fn, "%s.bak" % fn)
            except IOError as ex:
                pass
        else:
            print("%s is gone!" % fn)

    @staticmethod
    def enable_tf(fn):
        fn_old = "%s.bak" % fn
        if os.path.exists(fn_old):
            try:
                os.rename(fn_old, fn)
            except IOError:
                pass

    def clean_up(self):
        for o in self.p11_test_files:
            if os.path.isfile(o):
                os.unlink(o)
            elif os.path.isdir(o):
                rmtree(o)
        self.p11_test_files = []
